--- a/configure.ac
+++ b/configure.ac
@@ -100,6 +100,8 @@ if test "x$ac_cv_enable_polkit" = "xno";
     polkit="no"
 else
     AC_MSG_RESULT([yes])
+    XDT_CHECK_OPTIONAL_PACKAGE([SYSTEMD], [polkit-gobject-1], [0.100],
+                               [systemd], [Systemd support (through polkit)])
     AC_DEFINE(ENABLE_POLKIT, 1 , [PolicyKit support])
     polkit="yes"
 fi
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -39,6 +39,12 @@ xfce4_power_manager_SOURCES =
 	xfpm-errors.c				\
 	xfpm-errors.h
 
+if HAVE_SYSTEMD
+xfce4_power_manager_SOURCES +=			\
+	xfpm-systemd.c				\
+	xfpm-systemd.h
+endif
+
 xfce4_power_manager_CFLAGS =                    \
 	-I$(top_srcdir)                         \
 	-I$(top_srcdir)/common                  \
@@ -52,6 +58,7 @@ xfce4_power_manager_CFLAGS =
 	$(LIBXFCE4UI_CFLAGS)                    \
 	$(XFCONF_CFLAGS)                        \
 	$(LIBNOTIFY_CFLAGS)                     \
+	$(SYSTEMD_CFLAGS)                       \
 	$(XRANDR_CFLAGS)			\
 	$(DPMS_CFLAGS)           		\
 	$(PLATFORM_CPPFLAGS)			\
@@ -70,6 +77,7 @@ xfce4_power_manager_LDADD =
 	$(LIBXFCE4UI_LIBS)                      \
 	$(XFCONF_LIBS)                          \
 	$(LIBNOTIFY_LIBS)                       \
+	$(SYSTEMD_LIBS)                         \
 	$(XRANDR_LIBS)				\
 	$(DPMS_LIBS)
 
--- a/src/xfpm-manager.c
+++ b/src/xfpm-manager.c
@@ -58,6 +58,10 @@
 #include "xfpm-enum-types.h"
 #include "xfpm-dbus-monitor.h"
 
+#ifdef HAVE_SYSTEMD
+#include "xfpm-systemd.h"
+#endif
+
 static void xfpm_manager_finalize   (GObject *object);
 
 static void xfpm_manager_dbus_class_init (XfpmManagerClass *klass);
@@ -80,6 +84,9 @@ struct XfpmManagerPrivate
     XfpmButton      *button;
     XfpmXfconf      *conf;
     XfpmBacklight   *backlight;
+#ifdef HAVE_SYSTEMD
+    XfpmSystemd     *systemd;
+#endif
     XfpmConsoleKit  *console;
     XfpmDBusMonitor *monitor;
     XfpmDisks       *disks;
@@ -131,7 +138,12 @@ xfpm_manager_finalize (GObject *object)
     g_object_unref (manager->priv->button);
     g_object_unref (manager->priv->conf);
     g_object_unref (manager->priv->client);
-    g_object_unref (manager->priv->console);
+#ifdef HAVE_SYSTEMD
+    if ( manager->priv->systemd != NULL )
+	g_object_unref (manager->priv->systemd);
+#endif
+    if ( manager->priv->console != NULL )
+	g_object_unref (manager->priv->console);
     g_object_unref (manager->priv->monitor);
     g_object_unref (manager->priv->disks);
     g_object_unref (manager->priv->inhibit);
@@ -201,6 +213,11 @@ static void
 xfpm_manager_shutdown (XfpmManager *manager)
 {
     GError *error = NULL;
+#ifdef HAVE_SYSTEMD
+    if ( LOGIND_RUNNING () )
+	xfpm_systemd_shutdown (manager->priv->systemd, &error );
+    else
+#endif
     xfpm_console_kit_shutdown (manager->priv->console, &error );
     
     if ( error )
@@ -517,10 +534,17 @@ void xfpm_manager_start (XfpmManager *ma
     dbus_g_error_domain_register (XFPM_ERROR,
 				  NULL,
 				  XFPM_TYPE_ERROR);
-    
+
     manager->priv->power = xfpm_power_get ();
     manager->priv->button = xfpm_button_new ();
     manager->priv->conf = xfpm_xfconf_new ();
+#ifdef HAVE_SYSTEMD
+    manager->priv->console = NULL;
+    manager->priv->systemd = NULL;
+    if ( LOGIND_RUNNING () )
+	manager->priv->systemd = xfpm_systemd_new ();
+    else
+#endif
     manager->priv->console = xfpm_console_kit_new ();
     manager->priv->monitor = xfpm_dbus_monitor_new ();
     manager->priv->disks = xfpm_disks_new ();
@@ -603,6 +627,13 @@ GHashTable *xfpm_manager_get_config (Xfp
     
     hash = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
     
+#ifdef HAVE_SYSTEMD
+    if ( LOGIND_RUNNING () )
+	g_object_get (G_OBJECT (manager->priv->systemd),
+		      "can-shutdown", &can_shutdown,
+		      NULL);
+    else
+#endif
     g_object_get (G_OBJECT (manager->priv->console),
 		  "can-shutdown", &can_shutdown,
 		  NULL);
--- a/src/xfpm-power.c
+++ b/src/xfpm-power.c
@@ -51,6 +51,10 @@
 #include "xfpm-enum-types.h"
 #include "egg-idletime.h"
 
+#ifdef HAVE_SYSTEMD
+#include "xfpm-systemd.h"
+#endif
+
 static void xfpm_power_finalize     (GObject *object);
 
 static void xfpm_power_get_property (GObject *object,
@@ -78,6 +82,9 @@ struct XfpmPowerPrivate
 
     GHashTable      *hash;
     
+#ifdef HAVE_SYSTEMD
+    XfpmSystemd     *systemd;
+#endif
     XfpmConsoleKit  *console;
     XfpmInhibit	    *inhibit;
     XfpmXfconf      *conf;
@@ -723,10 +730,17 @@ xfpm_power_add_actions_to_notification (
 {
     gboolean can_shutdown;
     
+#ifdef HAVE_SYSTEMD
+    if ( LOGIND_RUNNING () )
+	g_object_get (G_OBJECT (power->priv->systemd),
+		      "can-shutdown", &can_shutdown,
+		      NULL);
+    else
+#endif
     g_object_get (G_OBJECT (power->priv->console),
 		  "can-shutdown", &can_shutdown,
 		  NULL);
-		  
+
     if (  power->priv->can_hibernate && power->priv->auth_hibernate )
     {
         xfpm_notify_add_action_to_notification(
@@ -799,10 +813,17 @@ xfpm_power_show_critical_action_gtk (Xfp
     const gchar *message;
     gboolean can_shutdown;
     
+#ifdef HAVE_SYSTEMD
+    if ( LOGIND_RUNNING () )
+	g_object_get (G_OBJECT (power->priv->systemd),
+		      "can-shutdown", &can_shutdown,
+		      NULL);
+    else
+#endif
     g_object_get (G_OBJECT (power->priv->console),
 		  "can-shutdown", &can_shutdown,
 		  NULL);
-    
+
     message = _("System is running on low power. "\
                "Save your work to avoid losing data");
     
@@ -1371,6 +1392,13 @@ xfpm_power_init (XfpmPower *power)
     power->priv->inhibit = xfpm_inhibit_new ();
     power->priv->notify  = xfpm_notify_new ();
     power->priv->conf    = xfpm_xfconf_new ();
+#ifdef HAVE_SYSTEMD
+    power->priv->systemd = NULL;
+    power->priv->console = NULL;
+    if ( LOGIND_RUNNING () )
+	power->priv->systemd = xfpm_systemd_new ();
+    else
+#endif
     power->priv->console = xfpm_console_kit_new ();
     
     g_signal_connect_swapped (power->priv->conf, "notify::" SHOW_TRAY_ICON_CFG,
@@ -1497,7 +1525,12 @@ xfpm_power_finalize (GObject *object)
     g_object_unref (power->priv->inhibit);
     g_object_unref (power->priv->notify);
     g_object_unref (power->priv->conf);
-    g_object_unref (power->priv->console);
+#ifdef HAVE_SYSTEMD
+    if ( power->priv->systemd != NULL )
+	g_object_unref (power->priv->systemd);
+#endif
+    if ( power->priv->console != NULL )
+	g_object_unref (power->priv->console);
     
     xfpm_power_hide_adapter_icon (power);
     
@@ -1664,10 +1697,17 @@ static gboolean xfpm_power_dbus_shutdown
 {
     gboolean can_reboot;
     
+#ifdef HAVE_SYSTEMD
+    if ( LOGIND_RUNNING () )
+	g_object_get (G_OBJECT (power->priv->systemd),
+		      "can-shutdown", &can_reboot,
+		      NULL);
+    else
+#endif
     g_object_get (G_OBJECT (power->priv->console),
 		  "can-shutdown", &can_reboot,
 		  NULL);
-    
+
     if ( !can_reboot)
     {
 	g_set_error (error, XFPM_ERROR, XFPM_ERROR_PERMISSION_DENIED,
@@ -1675,6 +1715,11 @@ static gboolean xfpm_power_dbus_shutdown
         return FALSE;
     }
     
+#ifdef HAVE_SYSTEMD
+    if ( LOGIND_RUNNING () )
+	xfpm_systemd_shutdown (power->priv->systemd, error);
+    else
+#endif
     xfpm_console_kit_shutdown (power->priv->console, error);
     
     return TRUE;
@@ -1685,10 +1730,17 @@ static gboolean xfpm_power_dbus_reboot
 {
     gboolean can_reboot;
     
+#ifdef HAVE_SYSTEMD
+    if ( LOGIND_RUNNING () )
+	g_object_get (G_OBJECT (power->priv->systemd),
+		      "can-restart", &can_reboot,
+		      NULL);
+    else
+#endif
     g_object_get (G_OBJECT (power->priv->console),
 		  "can-restart", &can_reboot,
 		  NULL);
-    
+
     if ( !can_reboot)
     {
 	g_set_error (error, XFPM_ERROR, XFPM_ERROR_PERMISSION_DENIED,
@@ -1696,7 +1748,12 @@ static gboolean xfpm_power_dbus_reboot
         return FALSE;
     }
     
+#ifdef HAVE_SYSTEMD
+    if ( LOGIND_RUNNING () )
+	xfpm_systemd_reboot (power->priv->systemd, error);
+#else
     xfpm_console_kit_reboot (power->priv->console, error);
+#endif
     
     return TRUE;
 }
@@ -1751,10 +1808,17 @@ static gboolean xfpm_power_dbus_can_rebo
 					  gboolean * OUT_can_reboot, 
 					  GError ** error)
 {
+#ifdef HAVE_SYSTEMD
+    if ( LOGIND_RUNNING () )
+	g_object_get (G_OBJECT (power->priv->systemd),
+		      "can-reboot", OUT_can_reboot,
+		      NULL);
+    else
+#endif
     g_object_get (G_OBJECT (power->priv->console),
 		  "can-reboot", OUT_can_reboot,
 		  NULL);
-		  
+
     return TRUE;
 }
 
@@ -1762,9 +1826,17 @@ static gboolean xfpm_power_dbus_can_shut
 					    gboolean * OUT_can_shutdown, 
 					    GError ** error)
 {
+#ifdef HAVE_SYSTEMD
+    if ( LOGIND_RUNNING () )
+	g_object_get (G_OBJECT (power->priv->systemd),
+		  "can-shutdown", OUT_can_shutdown,
+		  NULL);
+    else
+#endif
     g_object_get (G_OBJECT (power->priv->console),
 		  "can-shutdown", OUT_can_shutdown,
 		  NULL);
+
     return TRUE;
 }
 
--- /dev/null
+++ b/src/xfpm-systemd.c
@@ -0,0 +1,245 @@
+/*
+ * * Copyright (C) 2009-2011 Ali <aliov@xfce.org>
+ * * Copyright (C) 2013 Andreas Müller <schnitzeltony@googlemail.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <dbus/dbus-glib.h>
+#include <polkit/polkit.h>
+
+#include "xfpm-systemd.h"
+
+
+static void xfpm_systemd_finalize   (GObject *object);
+
+static void xfpm_systemd_get_property (GObject *object,
+                                       guint prop_id,
+                                       GValue *value,
+                                       GParamSpec *pspec);
+
+#define XFPM_SYSTEMD_GET_PRIVATE(o) \
+(G_TYPE_INSTANCE_GET_PRIVATE ((o), XFPM_TYPE_SYSTEMD, XfpmSystemdPrivate))
+
+struct XfpmSystemdPrivate
+{
+    gboolean	     can_shutdown;
+    gboolean	     can_restart;
+
+    PolkitAuthority *authority;
+    PolkitSubject   *subject;
+};
+
+enum
+{
+    PROP_0,
+    PROP_CAN_RESTART,
+    PROP_CAN_SHUTDOWN
+};
+
+G_DEFINE_TYPE (XfpmSystemd, xfpm_systemd, G_TYPE_OBJECT)
+
+#define SYSTEMD_DBUS_NAME               "org.freedesktop.login1"
+#define SYSTEMD_DBUS_PATH               "/org/freedesktop/login1"
+#define SYSTEMD_DBUS_INTERFACE          "org.freedesktop.login1.Manager"
+#define SYSTEMD_REBOOT_ACTION           "Reboot"
+#define SYSTEMD_POWEROFF_ACTION         "PowerOff"
+#define SYSTEMD_REBOOT_TEST             "org.freedesktop.login1.reboot"
+#define SYSTEMD_POWEROFF_TEST           "org.freedesktop.login1.power-off"
+
+static void
+xfpm_systemd_class_init (XfpmSystemdClass *klass)
+{
+    GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+    object_class->finalize = xfpm_systemd_finalize;
+
+    object_class->get_property = xfpm_systemd_get_property;
+
+    g_object_class_install_property (object_class,
+                                     PROP_CAN_RESTART,
+                                     g_param_spec_boolean ("can-restart",
+                                                           NULL, NULL,
+                                                           FALSE,
+                                                           G_PARAM_READABLE));
+
+    g_object_class_install_property (object_class,
+                                     PROP_CAN_SHUTDOWN,
+                                     g_param_spec_boolean ("can-shutdown",
+                                                           NULL, NULL,
+                                                           FALSE,
+                                                           G_PARAM_READABLE));
+
+    g_type_class_add_private (klass, sizeof (XfpmSystemdPrivate));
+}
+
+static gboolean
+xfpm_systemd_can_method (XfpmSystemd  *systemd,
+                         gboolean     *can_method,
+                         const gchar  *method)
+{
+    PolkitAuthorizationResult *res;
+    GError                    *local_error = NULL;
+
+    *can_method = FALSE;
+    res = polkit_authority_check_authorization_sync (systemd->priv->authority,
+                                                     systemd->priv->subject,
+                                                     method,
+                                                     NULL,
+                                                     POLKIT_CHECK_AUTHORIZATION_FLAGS_NONE,
+                                                     NULL,
+                                                     &local_error);
+    if ( local_error )
+    {
+	g_critical ("Unable to get %s : %s", method, local_error->message);
+	g_error_free (local_error);
+    }
+
+    if(res)
+    {
+        *can_method = polkit_authorization_result_get_is_authorized (res) ||
+                      polkit_authorization_result_get_is_challenge (res);
+        g_object_unref (G_OBJECT (res));
+    }
+
+    return TRUE;
+}
+
+static void
+xfpm_systemd_init (XfpmSystemd *systemd)
+{
+    systemd->priv = XFPM_SYSTEMD_GET_PRIVATE (systemd);
+    systemd->priv->authority = polkit_authority_get_sync (NULL, NULL);
+    systemd->priv->subject = polkit_unix_process_new (getpid());
+    systemd->priv->can_shutdown = FALSE;
+    systemd->priv->can_restart  = FALSE;
+
+    if(systemd->priv->authority && systemd->priv->subject)
+    {
+        xfpm_systemd_can_method (systemd,
+                                 &systemd->priv->can_shutdown,
+                                 SYSTEMD_POWEROFF_TEST);
+        xfpm_systemd_can_method (systemd,
+                                 &systemd->priv->can_restart,
+                                 SYSTEMD_REBOOT_TEST);
+    }
+}
+
+static void xfpm_systemd_get_property (GObject *object,
+					   guint prop_id,
+					   GValue *value,
+					   GParamSpec *pspec)
+{
+    XfpmSystemd *systemd;
+    systemd = XFPM_SYSTEMD (object);
+
+    switch (prop_id)
+    {
+	case PROP_CAN_SHUTDOWN:
+	    g_value_set_boolean (value, systemd->priv->can_shutdown);
+	    break;
+	case PROP_CAN_RESTART:
+	    g_value_set_boolean (value, systemd->priv->can_restart);
+	    break;
+        default:
+            G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+            break;
+    }
+}
+
+static void
+xfpm_systemd_finalize (GObject *object)
+{
+    XfpmSystemd *systemd;
+
+    systemd = XFPM_SYSTEMD (object);
+
+    if(systemd->priv->authority)
+        g_object_unref (G_OBJECT (systemd->priv->authority));
+    if(systemd->priv->subject)
+        g_object_unref (G_OBJECT (systemd->priv->subject));
+
+    G_OBJECT_CLASS (xfpm_systemd_parent_class)->finalize (object);
+}
+
+XfpmSystemd *
+xfpm_systemd_new (void)
+{
+    static gpointer systemd_obj = NULL;
+
+    if ( G_LIKELY (systemd_obj != NULL ) )
+    {
+	g_object_ref (systemd_obj);
+    }
+    else
+    {
+	systemd_obj = g_object_new (XFPM_TYPE_SYSTEMD, NULL);
+	g_object_add_weak_pointer (systemd_obj, &systemd_obj);
+    }
+
+    return XFPM_SYSTEMD (systemd_obj);
+}
+
+static void
+xfpm_systemd_try_method (XfpmSystemd  *systemd,
+                         const gchar  *method,
+                         GError      **error)
+{
+    GDBusConnection *bus;
+    GError          *local_error = NULL;
+
+    bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, error);
+    if (G_LIKELY (bus != NULL))
+    {
+        g_dbus_connection_call_sync (bus,
+                                     SYSTEMD_DBUS_NAME,
+                                     SYSTEMD_DBUS_PATH,
+                                     SYSTEMD_DBUS_INTERFACE,
+                                     method,
+                                     g_variant_new ("(b)", TRUE),
+                                     NULL, 0, G_MAXINT, NULL,
+                                     &local_error);
+        g_object_unref (G_OBJECT (bus));
+
+        if (local_error != NULL)
+        {
+            g_propagate_error (error, local_error);
+        }
+    }
+}
+
+void xfpm_systemd_shutdown (XfpmSystemd *systemd, GError **error)
+{
+    xfpm_systemd_try_method (systemd,
+                             SYSTEMD_POWEROFF_ACTION,
+                             error);
+}
+
+void xfpm_systemd_reboot (XfpmSystemd *systemd, GError **error)
+{
+    xfpm_systemd_try_method (systemd,
+                             SYSTEMD_REBOOT_ACTION,
+                             error);
+}
--- /dev/null
+++ b/src/xfpm-systemd.h
@@ -0,0 +1,62 @@
+/*
+ * * Copyright (C) 2009-2011 Ali <aliov@xfce.org>
+ * * Copyright (C) 2013 Andreas Müller <schnitzeltony@googlemail.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef __XFPM_SYSTEMD_H
+#define __XFPM_SYSTEMD_H
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define LOGIND_RUNNING() (access ("/run/systemd/seats/", F_OK) >= 0)
+
+#define XFPM_TYPE_SYSTEMD            (xfpm_systemd_get_type () )
+#define XFPM_SYSTEMD(o)              (G_TYPE_CHECK_INSTANCE_CAST ((o), XFPM_TYPE_SYSTEMD, XfpmSystemd))
+#define XFPM_IS_SYSTEMD(o)           (G_TYPE_CHECK_INSTANCE_TYPE ((o), XFPM_TYPE_SYSTEMD))
+
+typedef struct XfpmSystemdPrivate XfpmSystemdPrivate;
+
+typedef struct
+{
+    GObject         		parent;
+    XfpmSystemdPrivate		*priv;
+
+} XfpmSystemd;
+
+typedef struct
+{
+    GObjectClass 		parent_class;
+
+} XfpmSystemdClass;
+
+GType				xfpm_systemd_get_type	(void) G_GNUC_CONST;
+
+XfpmSystemd			*xfpm_systemd_new	(void);
+
+void				xfpm_systemd_shutdown	(XfpmSystemd *systemd,
+							 GError **error);
+
+void				xfpm_systemd_reboot	(XfpmSystemd *systemd,
+							 GError **error);
+
+G_END_DECLS
+
+#endif /* __XFPM_SYSTEMD_H */
